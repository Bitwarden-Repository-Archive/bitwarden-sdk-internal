// @ts-check
const fs = require("fs");
const path = require("path");
const ts = require("typescript");

// The root SDK client, and the main entry point for the remote IPC-based client
const ROOT_CLIENT = "BitwardenClient";

const SKIP_METHODS = [
  // This methods is generated by the `wasm-bindgen` macro and is not async
  "free",
];

// Read the types definition file and create an AST
const jsFilename = path.resolve(__dirname, "npm/bitwarden_wasm_internal_bg.js");
const tsFilename = path.resolve(__dirname, "npm/bitwarden_wasm_internal.d.ts");
const jsCode = fs.readFileSync(jsFilename, "utf-8");
const tsCode = fs.readFileSync(tsFilename, "utf-8");
const ast = ts.createSourceFile(tsFilename, tsCode, ts.ScriptTarget.Latest);

/** @type {Set<string>} */
const allClasses = new Set();

/** @type {Record<string, Record<string, string>>} */
const allTransitions = {};

/** @type {{className: string, methodName: string}[]} */
const syncMethods = [];

// First collect all the classes
ast.forEachChild((child) => {
  if (ts.isClassDeclaration(child) && child.name) {
    allClasses.add(child.name.text);
  }
});

// Then create the transitions table and validate that all functions are async
ast.forEachChild((child) => {
  if (ts.isClassDeclaration(child) && child.name) {
    const className = child.name.text;
    child.members.forEach((member) => {
      if (ts.isMethodDeclaration(member) && ts.isIdentifier(member.name)) {
        const methodName = member.name.text;
        if (SKIP_METHODS.includes(methodName)) {
          return;
        }

        // Get the return type of the method. If it's a class, add it to the transitions table
        if (
          member.type &&
          ts.isTypeReferenceNode(member.type) &&
          ts.isIdentifier(member.type.typeName)
        ) {
          const returnType = member.type.typeName.text;
          if (allClasses.has(returnType)) {
            allTransitions[className] ??= {};
            allTransitions[className][returnType] = methodName;
          }
          return;
        }

        // Check if the method is async, and take note of them if not
        if (!member.modifiers?.some((modifier) => modifier.kind === ts.SyntaxKind.AsyncKeyword)) {
          syncMethods.push({ className, methodName });
        }
      }
    });
  }
});

// Generate the sub-clients table by following all the transitions from the root client.
// Also keep track of all the clients that are seen, so we can ensure that all their methods are sync.
/**
 * @param {string} clientName
 * @param {Record<string, any>} output
 * @param {Set<string>} seenClients
 */
function addSubClients(clientName, output, seenClients) {
  seenClients.add(clientName);
  for (const [subClient, func] of Object.entries(allTransitions[clientName] ?? {})) {
    seenClients.add(subClient);
    output[func] ??= {};
    addSubClients(subClient, output[func], seenClients);
  }
}
const subClients = {};
const seenClients = new Set();
addSubClients(ROOT_CLIENT, subClients, seenClients);

// Save the sub-clients table to the types file
const SEPARATOR = "/* The following code is generated by the validate_wasm_types.js script */";
fs.writeFileSync(
  jsFilename,
  `${jsCode.split(SEPARATOR)[0]}
${SEPARATOR}
export const SUB_CLIENT_METHODS = ${JSON.stringify(subClients, null, 2)};
`,
);
fs.writeFileSync(
  tsFilename,
  `${tsCode.split(SEPARATOR)[0]}
${SEPARATOR}
export declare const SUB_CLIENT_METHODS: Record<string, any>;
`,
);

// Report any errors and exit with a non-zero code
let hasSyncMethods = false;
for (const { className, methodName } of syncMethods) {
  if (seenClients.has(className)) {
    console.error(`[ERROR] Method ${className}.${methodName} is not async`);
    hasSyncMethods = true;
  }
}

if (hasSyncMethods) {
  console.error(
    "Some methods in the SDK clients are not async. To support being used through an IPC channel, all methods must be async.",
  );
  process.exit(1);
}
